----------------------------------------/ CONFIG START \----------------------------------------

local amountScript = 52 -- Quantos src tem no script
local resName = "[MST]GroupSystem" -- Nome da resource no site
local configName = "resources/config.lua"
local permittedServerFunctions = {
    ["Utilitys.mst"] = true,
    ["Utilitys.mstc"] = true,
    ["CreateGroupCommand.mstc"] = true,
    ["[C]"] = true, -- AntBug
}-- Nome do "server" aonde esta a protecao
local funcs = {fromJSON, toJSON, stopResource, fetchRemote, cancelEvent, addDebugHook, math.random, string.find} -- Bloqueados no debug.getinfo
local blockCharacters = {"fromJSON", "toJSON", "stopResource", "fetchRemote", "cancelEvent", "addDebugHook", "string.find", "math.random"} -- Palavras bloqueadas de ficar na config

----------------------------------------/ CONFIG END \----------------------------------------

----------------------------------------/ JSON \----------------------------------------
local json = {}

local function kind_of(obj)
    if type(obj) ~= 'table' then
        return type(obj)
    end
    local i = 1
    for _ in pairs(obj) do
        if obj[i] ~= nil then
            i = i + 1
        else
            return 'table'
        end
    end
    if i == 1 then
        return 'table'
    else
        return 'array'
    end
end

local function escape_str(s)
    local in_char = {'\\', '"', '/', '\b', '\f', '\n', '\r', '\t'}
    local out_char = {'\\', '"', '/', 'b', 'f', 'n', 'r', 't'}
    for i, c in ipairs(in_char) do
        s = s:gsub(c, '\\' .. out_char[i])
    end
    return s
end

local function skip_delim(str, pos, delim, err_if_missing)
    pos = pos + #str:match('^%s*', pos)
    if str:sub(pos, pos) ~= delim then
        if err_if_missing then
            error('Expected ' .. delim .. ' near position ' .. pos)
        end
        return pos, false
    end
    return pos + 1, true
end

local function parse_str_val(str, pos, val)
    val = val or ''
    local early_end_error = 'End of input found while parsing string.'
    if pos > #str then
        error(early_end_error)
    end
    local c = str:sub(pos, pos)
    if c == '"' then
        return val, pos + 1
    end
    if c ~= '\\' then
        return parse_str_val(str, pos + 1, val .. c)
    end

    local esc_map = {
        b = '\b',
        f = '\f',
        n = '\n',
        r = '\r',
        t = '\t'
    }
    local nextc = str:sub(pos + 1, pos + 1)
    if not nextc then
        error(early_end_error)
    end
    return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local function parse_num_val(str, pos)
    local num_str = str:match('^-?%d+%.?%d*[eE]?[+-]?%d*', pos)
    local val = tonumber(num_str)
    if not val then
        error('Error parsing number at position ' .. pos .. '.')
    end
    return val, pos + #num_str
end

function json.stringify(obj, as_key)
    local s = {}
    local kind = kind_of(obj)
    if kind == 'array' then
        if as_key then
            error('Can\'t encode array as key.')
        end
        s[#s + 1] = '['
        for i, val in ipairs(obj) do
            if i > 1 then
                s[#s + 1] = ', '
            end
            s[#s + 1] = json.stringify(val)
        end
        s[#s + 1] = ']'
    elseif kind == 'table' then
        if as_key then
            error('Can\'t encode table as key.')
        end
        s[#s + 1] = '{'
        for k, v in pairs(obj) do
            if #s > 1 then
                s[#s + 1] = ', '
            end
            s[#s + 1] = json.stringify(k, true)
            s[#s + 1] = ':'
            s[#s + 1] = json.stringify(v)
        end
        s[#s + 1] = '}'
    elseif kind == 'string' then
        return '"' .. escape_str(obj) .. '"'
    elseif kind == 'number' then
        if as_key then
            return '"' .. myToString(obj) .. '"'
        end
        return myToString(obj)
    elseif kind == 'boolean' then
        return myToString(obj)
    elseif kind == 'nil' then
        return 'null'
    else
        error('Unjsonifiable type: ' .. kind .. '.')
    end
    return table.concat(s)
end

json.null = {}

function json.parse(str, pos, end_delim)
    pos = pos or 1
    if pos > #str then
        error('Reached unexpected end of input.')
    end
    local pos = pos + #str:match('^%s*', pos) -- Skip whitespace.
    local first = str:sub(pos, pos)
    if first == '{' then -- Parse an object.
        local obj, key, delim_found = {}, true, true
        pos = pos + 1
        while true do
            key, pos = json.parse(str, pos, '}')
            if key == nil then
                return obj, pos
            end
            if not delim_found then
                error('Comma missing between object items.')
            end
            pos = skip_delim(str, pos, ':', true) -- true -> error if missing.
            obj[key], pos = json.parse(str, pos)
            pos, delim_found = skip_delim(str, pos, ',')
        end
    elseif first == '[' then -- Parse an array.
        local arr, val, delim_found = {}, true, true
        pos = pos + 1
        while true do
            val, pos = json.parse(str, pos, ']')
            if val == nil then
                return arr, pos
            end
            if not delim_found then
                error('Comma missing between array items.')
            end
            arr[#arr + 1] = val
            pos, delim_found = skip_delim(str, pos, ',')
        end
    elseif first == '"' then -- Parse a string.
        return parse_str_val(str, pos + 1)
    elseif first == '-' or first:match('%d') then -- Parse a number.
        return parse_num_val(str, pos)
    elseif first == end_delim then -- End of an object or array.
        return nil, pos + 1
    else -- Parse true, false, or null.
        local literals = {
            ['true'] = true,
            ['false'] = false,
            ['null'] = json.null
        }
        for lit_str, lit_val in pairs(literals) do
            local lit_end = pos + #lit_str - 1
            if str:sub(pos, lit_end) == lit_str then
                return lit_val, lit_end + 1
            end
        end
        local pos_info_str = 'position ' .. pos .. ': ' .. str:sub(pos, pos + 10)
        error('Invalid json syntax starting at ' .. pos_info_str)
    end
end

local function getResourceFiles(res)
    if (getLocalPlayer) then
        error('A função @getResourceFiles deve ser usada somente em server-side', 2)
    end
    res = (res == nil) and getThisResource() or res
    if not (type(res) == 'userdata' and getUserdataType(res) == 'resource-data') then
        error("@getResourceFiles argumento #1. Esperado um 'resource-data', obtido '" .. (type(res) == 'userdata' and getUserdataType(res) or myToString(res)) .. "' (tipo: " .. type(res) .. ")", 2)
    end
    local files = {}
    files.script = {}
    files.file = {}
    files.map = {}
    files.config = {}
    files.html = {}
    local allFiles = {}
    local filesonlyname = {}
    local thisResource = res == getThisResource() and res or false
    local charsTypes = '%.%%w%d%|%%<%>%:%(%)%&%;%#%?%*'
    local nomeResource = getThisResource():getName()

    local Meta = XML.load(':' .. nomeResource .. '/meta.xml')
    if not Meta then
        error("(@getResourceFiles) Não foi possível obter o 'meta.xml' do resource '" .. nomeResource .. "'", 2)
    end
    for _, nod in ipairs(Meta:getChildren()) do
        local nodeName = nod:getName()
        local srcAttribute = nod:getAttribute('src')
        if (srcAttribute and files[nodeName]) then
            local onlyFileName = myToString(srcAttribute:match('/([' .. charsTypes .. ']+%.[' .. charsTypes .. ']+)') or
                                              srcAttribute)
            table.insert(files[nodeName], srcAttribute)
            table.insert(allFiles, srcAttribute)
            table.insert(filesonlyname, onlyFileName)
        end
    end
    Meta:unload()
    return files, #allFiles > 0 and allFiles or false, #filesonlyname > 0 and filesonlyname or false
end

local function checkFuncs()
    for i = 1, #funcs do
        if (debug.getinfo(funcs[i]).what ~= "C") then
            return "modificou"
        else
            if (debug.getinfo(funcs[i]).source ~= "=[C]") then
                return "modificou"
            else
                if (debug.getinfo(funcs[i]).short_src ~= "[C]") then
                    return "modificou"
                end
            end
        end
    end
    return "não modificou"
end

----------------------- BIT METHOD -----------------------

local M = {
    _TYPE = 'module',
    _NAME = 'bit.numberlua',
    _VERSION = '0.3.1.20120131'
}

local floor = math.floor

local MOD = 2 ^ 32
local MODM = MOD - 1

local function memoize(f)
    local mt = {}
    local t = setmetatable({}, mt)
    function mt:__index(k)
        local v = f(k);
        t[k] = v
        return v
    end
    return t
end

local function make_bitop_uncached(t, m)
    local function bitop(a, b)
        local res, p = 0, 1
        while a ~= 0 and b ~= 0 do
            local am, bm = a % m, b % m
            res = res + t[am][bm] * p
            a = (a - am) / m
            b = (b - bm) / m
            p = p * m
        end
        res = res + (a + b) * p
        return res
    end
    return bitop
end

local function make_bitop(t)
    local op1 = make_bitop_uncached(t, 2 ^ 1)
    local op2 = memoize(function(a)
        return memoize(function(b)
            return op1(a, b)
        end)
    end)
    return make_bitop_uncached(op2, 2 ^ (t.n or 1))
end

function M.tobit(x)
    return x % 2 ^ 32
end

M.bxor = make_bitop {
    [0] = {
        [0] = 0,
        [1] = 1
    },
    [1] = {
        [0] = 1,
        [1] = 0
    },
    n = 4
}
local bxor = M.bxor

function M.bnot(a)
    return MODM - a
end
local bnot = M.bnot

function M.band(a, b)
    return ((a + b) - bxor(a, b)) / 2
end
local band = M.band

function M.bor(a, b)
    return MODM - band(MODM - a, MODM - b)
end
local bor = M.bor

local lshift, rshift
function M.rshift(a, disp) -- Lua5.2 insipred
    if disp < 0 then
        return lshift(a, -disp)
    end
    return floor(a % 2 ^ 32 / 2 ^ disp)
end
rshift = M.rshift

function M.lshift(a, disp) -- Lua5.2 inspired
    if disp < 0 then
        return rshift(a, -disp)
    end
    return (a * 2 ^ disp) % 2 ^ 32
end
lshift = M.lshift

function M.tohex(x, n) -- BitOp style
    n = n or 8
    local up
    if n <= 0 then
        if n == 0 then
            return ''
        end
        up = true
        n = -n
    end
    x = band(x, 16 ^ n - 1)
    return ('%0' .. n .. (up and 'X' or 'x')):format(x)
end
local tohex = M.tohex

function M.extract(n, field, width)
    width = width or 1
    return band(rshift(n, field), 2 ^ width - 1)
end
local extract = M.extract

function M.replace(n, v, field, width)
    width = width or 1
    local mask1 = 2 ^ width - 1
    v = band(v, mask1)
    local mask = bnot(lshift(mask1, field))
    return band(n, mask) + lshift(v, field)
end
local replace = M.replace

function M.bswap(x)
    local a = band(x, 0xff);
    x = rshift(x, 8)
    local b = band(x, 0xff);
    x = rshift(x, 8)
    local c = band(x, 0xff);
    x = rshift(x, 8)
    local d = band(x, 0xff)
    return lshift(lshift(lshift(a, 8) + b, 8) + c, 8) + d
end
local bswap = M.bswap

function M.rrotate(x, disp)
    disp = disp % 32
    local low = band(x, 2 ^ disp - 1)
    return rshift(x, disp) + lshift(low, 32 - disp)
end
local rrotate = M.rrotate

function M.lrotate(x, disp)
    return rrotate(x, -disp)
end
local lrotate = M.lrotate

M.rol = M.lrotate
M.ror = M.rrotate

function M.arshift(x, disp)
    local z = rshift(x, disp)
    if x >= 0x80000000 then
        z = z + lshift(2 ^ disp - 1, 32 - disp)
    end
    return z
end
local arshift = M.arshift

function M.btest(x, y)
    return band(x, y) ~= 0
end

--
-- Start Lua 5.2 "bit32" compat section.
--

M.bit32 = {}

local function bit32_bnot(x)
    return (-1 - x) % MOD
end
M.bit32.bnot = bit32_bnot

local function bit32_bxor(a, b, c, ...)
    local z
    if b then
        a = a % MOD
        b = b % MOD
        z = bxor(a, b)
        if c then
            z = bit32_bxor(z, c, ...)
        end
        return z
    elseif a then
        return a % MOD
    else
        return 0
    end
end
M.bit32.bxor = bit32_bxor

local function bit32_band(a, b, c, ...)
    local z
    if b then
        a = a % MOD
        b = b % MOD
        z = ((a + b) - bxor(a, b)) / 2
        if c then
            z = bit32_band(z, c, ...)
        end
        return z
    elseif a then
        return a % MOD
    else
        return MODM
    end
end
M.bit32.band = bit32_band

local function bit32_bor(a, b, c, ...)
    local z
    if b then
        a = a % MOD
        b = b % MOD
        z = MODM - band(MODM - a, MODM - b)
        if c then
            z = bit32_bor(z, c, ...)
        end
        return z
    elseif a then
        return a % MOD
    else
        return 0
    end
end
M.bit32.bor = bit32_bor

function M.bit32.btest(...)
    return bit32_band(...) ~= 0
end

function M.bit32.lrotate(x, disp)
    return lrotate(x % MOD, disp)
end

function M.bit32.rrotate(x, disp)
    return rrotate(x % MOD, disp)
end

function M.bit32.lshift(x, disp)
    if disp > 31 or disp < -31 then
        return 0
    end
    return lshift(x % MOD, disp)
end

function M.bit32.rshift(x, disp)
    if disp > 31 or disp < -31 then
        return 0
    end
    return rshift(x % MOD, disp)
end

function M.bit32.arshift(x, disp)
    x = x % MOD
    if disp >= 0 then
        if disp > 31 then
            return (x >= 0x80000000) and MODM or 0
        else
            local z = rshift(x, disp)
            if x >= 0x80000000 then
                z = z + lshift(2 ^ disp - 1, 32 - disp)
            end
            return z
        end
    else
        return lshift(x, -disp)
    end
end

function M.bit32.extract(x, field, ...)
    local width = ... or 1
    if field < 0 or field > 31 or width < 0 or field + width > 32 then
        error 'out of range'
    end
    x = x % MOD
    return extract(x, field, ...)
end

function M.bit32.replace(x, v, field, ...)
    local width = ... or 1
    if field < 0 or field > 31 or width < 0 or field + width > 32 then
        error 'out of range'
    end
    x = x % MOD
    v = v % MOD
    return replace(x, v, field, ...)
end

M.bit = {}

function M.bit.tobit(x)
    x = x % MOD
    if x >= 0x80000000 then
        x = x - MOD
    end
    return x
end
local bit_tobit = M.bit.tobit

function M.bit.tohex(x, ...)
    return tohex(x % MOD, ...)
end

function M.bit.bnot(x)
    return bit_tobit(bnot(x % MOD))
end

local function bit_bor(a, b, c, ...)
    if c then
        return bit_bor(bit_bor(a, b), c, ...)
    elseif b then
        return bit_tobit(bor(a % MOD, b % MOD))
    else
        return bit_tobit(a)
    end
end
M.bit.bor = bit_bor

local function bit_band(a, b, c, ...)
    if c then
        return bit_band(bit_band(a, b), c, ...)
    elseif b then
        return bit_tobit(band(a % MOD, b % MOD))
    else
        return bit_tobit(a)
    end
end
M.bit.band = bit_band

local function bit_bxor(a, b, c, ...)
    if c then
        return bit_bxor(bit_bxor(a, b), c, ...)
    elseif b then
        return bit_tobit(bxor(a % MOD, b % MOD))
    else
        return bit_tobit(a)
    end
end
M.bit.bxor = bit_bxor

function M.bit.lshift(x, n)
    return bit_tobit(lshift(x % MOD, n % 32))
end

function M.bit.rshift(x, n)
    return bit_tobit(rshift(x % MOD, n % 32))
end

function M.bit.arshift(x, n)
    return bit_tobit(arshift(x % MOD, n % 32))
end

function M.bit.rol(x, n)
    return bit_tobit(lrotate(x % MOD, n % 32))
end

function M.bit.ror(x, n)
    return bit_tobit(rrotate(x % MOD, n % 32))
end

function M.bit.bswap(x)
    return bit_tobit(bswap(x % MOD))
end

local w, n, m, r = 32, 624, 397, 31
local a = 0x9908B0DF
local u = 11
local s, b = 7, 0x9D2C5680
local t, c = 15, 0xEFC60000
local l = 18
local f = 1812433253

local bnot = M.bit.bnot
local bxor = bit_bxor
local band = bit_band
local bor = M.bit.bor
local rshift = M.bit.rshift
local lshift = M.bit.lshift
local function int32(int)
    return band(int, 0xFFFFFFFF)
end

local MT = {}
local index = n + 1
local lower_mask = lshift(1, r) - 1
local upper_mask = int32(bnot(lower_mask))

function M.seed_mt(seed)
    index = n
    if not seed then
        seed = os.time()
    end
    MT[0] = int32(seed)
    for i = 1, n - 1 do
        MT[i] = int32(f * bxor(MT[i - 1], rshift(MT[i - 1], w - 2) + i))
    end
end

function M.extract_number()
    if index >= n then
        if index > n then
            M.seed_mt()
        end
        M.twist()
    end

    local y = MT[index]
    y = bxor(y, rshift(y, u))
    y = bxor(y, band(lshift(y, s), b))
    y = bxor(y, band(lshift(y, t), c))
    y = bxor(y, rshift(y, l))

    index = index + 1
    return int32(y)
end

function M.twist()
    for i = 0, n - 1 do
        local x = bor(band(MT[i], upper_mask), band(MT[(i + 1) % n], lower_mask))
        local xA = rshift(x, 1)
        if x % 2 ~= 0 then
            xA = bxor(xA, a)
        end
        MT[i] = int32(bxor(MT[(i + m) % n], xA))
    end
    index = 0
end

function M.random(p, q)
    if p then
        if q then
            return p + M.extract_number() % (q - p + 1)
        else
            return 1 + M.extract_number() % p
        end
    else
        return M.extract_number() / 0xFFFFFFFF
    end
end

-------------------/PROTECAO UTIL\------------------

function configMalicious(configName)
    local file = File(configName)
    if (file) then
        local data = file:read(file.size)
        local result = "não modificou"

        for k, v in pairs(blockCharacters) do
            if (findString(data, v)) then
                result = "Modificado"
                break
            end
        end

        return result
    else
        return "Modificado"
    end

    setTimer(function()
        file:close()
    end, 4000, 1)
end

local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
-- encoding
function b64(data)
    return ((data:gsub('.', function(x)
        local r, b = '', x:byte()
        for i = 8, 1, -1 do
            r = r .. (b % 2 ^ i - b % 2 ^ (i - 1) > 0 and '1' or '0')
        end
        return r;
    end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then
            return ''
        end
        local c = 0
        for i = 1, 6 do
            c = c + (x:sub(i, i) == '1' and 2 ^ (6 - i) or 0)
        end
        return b:sub(c + 1, c + 1)
    end) .. ({'', '==', '='})[#data % 3 + 1])
end

function encode(s)
    local u
    local padding_len = 2 - ((#s - 1) % 3)

    if padding_len > 0 then
        u = b64(s):sub(1, -padding_len - 1)
    else
        u = b64(s)
    end

    if u then
        return u
    else
        return nil
    end
end

local alphabet = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
                  "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",
                  "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "1", "2", "3", "4", "5", "6", "7", "8",
                  "9", "0"}

local function generatePassword(length, numbers, symbols)
    local text = ""

    for i = 1, length do
        text = text .. "" .. alphabet[M.random(1, #alphabet)]
    end

    return text
end

----------------------------------------/ HASH 256 \----------------------------------------

local MOD = 2 ^ 32
local MODM = MOD - 1

local function memoize(f)
    local mt = {}
    local t = setmetatable({}, mt)
    function mt:__index(k)
        local v = f(k)
        t[k] = v
        return v
    end
    return t
end

local function make_bitop_uncached(t, m)
    local function bitop(a, b)
        local res, p = 0, 1
        while a ~= 0 and b ~= 0 do
            local am, bm = a % m, b % m
            res = res + t[am][bm] * p
            a = (a - am) / m
            b = (b - bm) / m
            p = p * m
        end
        res = res + (a + b) * p
        return res
    end
    return bitop
end

local function make_bitop(t)
    local op1 = make_bitop_uncached(t, 2 ^ 1)
    local op2 = memoize(function(a)
        return memoize(function(b)
            return op1(a, b)
        end)
    end)
    return make_bitop_uncached(op2, 2 ^ (t.n or 1))
end

local bxor1 = make_bitop({
    [0] = {
        [0] = 0,
        [1] = 1
    },
    [1] = {
        [0] = 1,
        [1] = 0
    },
    n = 4
})

local function bxor(a, b, c, ...)
    local z = nil
    if b then
        a = a % MOD
        b = b % MOD
        z = bxor1(a, b)
        if c then
            z = bxor(z, c, ...)
        end
        return z
    elseif a then
        return a % MOD
    else
        return 0
    end
end

local function band(a, b, c, ...)
    local z
    if b then
        a = a % MOD
        b = b % MOD
        z = ((a + b) - bxor1(a, b)) / 2
        if c then
            z = bit32_band(z, c, ...)
        end
        return z
    elseif a then
        return a % MOD
    else
        return MODM
    end
end

local function bnot(x)
    return (-1 - x) % MOD
end

local function rshift1(a, disp)
    if disp < 0 then
        return lshift(a, -disp)
    end
    return math.floor(a % 2 ^ 32 / 2 ^ disp)
end

local function rshift(x, disp)
    if disp > 31 or disp < -31 then
        return 0
    end
    return rshift1(x % MOD, disp)
end

local function lshift(a, disp)
    if disp < 0 then
        return rshift(a, -disp)
    end
    return (a * 2 ^ disp) % 2 ^ 32
end

local function rrotate(x, disp)
    x = x % MOD
    disp = disp % 32
    local low = band(x, 2 ^ disp - 1)
    return rshift(x, disp) + lshift(low, 32 - disp)
end

local k = {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,
           0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
           0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8,
           0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
           0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
           0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
           0xc67178f2}

local function str2hexa(s)
    return (string.gsub(s, ".", function(c)
        return string.format("%02x", string.byte(c))
    end))
end

local function num2s(l, n)
    local s = ""
    for i = 1, n do
        local rem = l % 256
        s = string.char(rem) .. s
        l = (l - rem) / 256
    end
    return s
end

local function s232num(s, i)
    local n = 0
    for i = i, i + 3 do
        n = n * 256 + string.byte(s, i)
    end
    return n
end

local function preproc(msg, len)
    local extra = 64 - ((len + 9) % 64)
    len = num2s(8 * len, 8)
    msg = msg .. "\128" .. string.rep("\0", extra) .. len
    assert(#msg % 64 == 0)
    return msg
end

local function initH256(H)
    H[1] = 0x6a09e667
    H[2] = 0xbb67ae85
    H[3] = 0x3c6ef372
    H[4] = 0xa54ff53a
    H[5] = 0x510e527f
    H[6] = 0x9b05688c
    H[7] = 0x1f83d9ab
    H[8] = 0x5be0cd19
    return H
end

local function digestblock(msg, i, H)
    local w = {}
    for j = 1, 16 do
        w[j] = s232num(msg, i + (j - 1) * 4)
    end
    for j = 17, 64 do
        local v = w[j - 15]
        local s0 = bxor(rrotate(v, 7), rrotate(v, 18), rshift(v, 3))
        v = w[j - 2]
        w[j] = w[j - 16] + s0 + w[j - 7] + bxor(rrotate(v, 17), rrotate(v, 19), rshift(v, 10))
    end

    local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
    for i = 1, 64 do
        local s0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))
        local maj = bxor(band(a, b), band(a, c), band(b, c))
        local t2 = s0 + maj
        local s1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))
        local ch = bxor(band(e, f), band(bnot(e), g))
        local t1 = h + s1 + ch + k[i] + w[i]
        h, g, f, e, d, c, b, a = g, f, e, d + t1, c, b, a, t1 + t2
    end

    H[1] = band(H[1] + a)
    H[2] = band(H[2] + b)
    H[3] = band(H[3] + c)
    H[4] = band(H[4] + d)
    H[5] = band(H[5] + e)
    H[6] = band(H[6] + f)
    H[7] = band(H[7] + g)
    H[8] = band(H[8] + h)
end

function findString(s1, s2)
    for i = 1, #s1 - #s2 + 1 do
        local t = s1:sub(i, #s2 + i - 1)
        if (t == s2) then
            return i, i + #s2 - 1
        end
    end
end

function encryptMistic(msg)
    msg = preproc(msg, #msg)
    local H = initH256({})
    for i = 1, #msg, 64 do
        digestblock(msg, i, H)
    end
    return str2hexa(num2s(H[1], 4) .. num2s(H[2], 4) .. num2s(H[3], 4) .. num2s(H[4], 4) .. num2s(H[5], 4) .. num2s(H[6], 4) .. num2s(H[7], 4) .. num2s(H[8], 4))
end

math.round = function(number, decimals, method)
    if decimals and method then
        decimals = decimals or 0
        local factor = 10 ^ decimals
        if (method == "ceil" or method == "floor") then
            return math[method](number * factor) / factor
        else
            return tonumber(("%." .. decimals .. "f"):format(number))
        end
    else
        local _, decimals = math.modf(number)
        if decimals < 0.5 then
            return math.floor(number)
        end
        return math.ceil(number)
    end
end

local used = {}
function getMeRandom(maxNr)
    if (maxNr == nil) then
        maxNr = 100
    end

    local random = math.round((M.random() * maxNr))
    if random == nil or used[random] then
        return getMeRandom(maxNR)
    end
    used[random] = true
    return random
end

function containTable(tableNew, valueString)
    local valueFinal = false

    for k, v in pairs(tableNew) do
        if (tableNew[k] == valueString) then
            valueFinal = true
            break
        end
    end

    return valueFinal
end

function myToString(value)
    return ""..value
end

-------------------/PROTECAO INIT\-------------------

local dataLicence = {}
local tokenValid = {}

function licenceStop()
    print("Alguma informacao esta errada.")
    cancelEvent()
    dataLicence[1] = "Error"
    getThisResource():stop()
end

function onPreFunction(resource, functionanem, isAllowed, luafile, lualinenumber)
    if (resource == getThisResource()) then
        local result = false
        for k, v in pairs(blockCharacters) do
            if (findString(functionanem, v)) then
                result = "Modificado"
                break
            end
        end

        if (result == "Modificado") then
            if not (permittedServerFunctions[luafile]) then
                cancelEvent()
                dataLicence[1] = "Error"
                getThisResource():stop()
                print("Error: "..encode("LOG1: "..luafile))
            end
        end
    end
end
addDebugHook("postFunction", onPreFunction)

_iprint = iprint
function iprint(...)
    if (findString(..., "misticstore.com") or findString(..., "secretToken")) then
        licenceStop()
        return
    end

    return _iprint(...)
end

_print = print
function print(...)
    if (findString(..., "misticstore.com") or findString(..., "secretToken")) then
        licenceStop()
        return
    end

    return _print(...)
end

function onStartProtect(res)
    if not (res == getThisResource()) then return end

    if (checkFuncs() == "não modificou") then
        if (#getResourceFiles(getThisResource())["script"] == amountScript) then
            if (containTable(getResourceFiles(getThisResource())["script"], configName)) then
                if (configMalicious(configName) == "não modificou") then
                    if not (hasObjectPermissionTo(getThisResource(), "function.fetchRemote", false)) then
                        print("Adicione a resource no admin, para que possamos usar o function.fetchRemote!")
                        cancelEvent()
                        dataLicence[1] = "Error"
                        getThisResource():stop()
                        return
                    end

                    dataLicence["Cache"] = {}
                    dataLicence["Cache"]["Time"] = getRealTime().timestamp
                    dataLicence["Cache"]["OsTime"] = os.time()

                    local time = getRealTime().timestamp + 1
                    local timeEncode = encode(myToString(time))

                    local random1 = generatePassword(4, true, true)
                    local salt = generatePassword(9, false, true)
                    local random3 = generatePassword(6, true, true)

                    local varPrincipal = encode(resName)
                    local serverPort = encode(myToString(getServerPort()))

                    local Random = generatePassword(12, 6, 6)

                    local var = "$2a$10$" .. encode(random1 .. "/" .. varPrincipal .. "/" .. serverPort .. "/" .. random3 .. "/" .. timeEncode .. "/" .. salt)
                    local secretKey = '$SHA256$' .. encryptMistic(encryptMistic("secretKey" .. Random .. "-MST") .. "-MST")

                    sendPostData = {
                        formFields = {
                            secretKey = secretKey,
                            realTime = time,
                            apiVerify = Random,
                            passwordHash = var
                        }
                    }

                    if not (_fetchRemote) then
                        setTimer(function()
                            fetchRemote("https://misticstore.com/license/verify", sendPostData, function(response)
                                if (response) then
                                    responseJson = response or '{"state":false,"mensagem":"Erro ao checkar a API!"}';

                                    if (dataLicence["Cache"]["Time"] == getRealTime().timestamp) then
                                        licenceStop()
                                        print("Error: "..encode("Tempo 1"))
                                        return
                                    end
                                    
                                    if (dataLicence["Cache"]["OsTime"] == os.time()) then
                                        licenceStop()
                                        print("Error: "..encode("Tempo 2"))
                                        return
                                    end
                                    
                                    local user = config["License"]["User"]
                                    local userKey = config["License"]["Key"]
                                    
                                    local valAll = user .. "/" .. userKey;
                                    local enc = '$SHA256$' .. encryptMistic(encryptMistic(valAll) .. salt) .. salt;
                                    
                                    if (json.parse(responseJson).status ~= nil) then
                                        print(json.parse(responseJson).message)
                                        cancelEvent()
                                        dataLicence[1] = "Error"
                                        getThisResource():stop()
                                        return
                                    end
                                    
                                    local tokenFromSite = json.parse(responseJson).secretToken
                                    if (tokenFromSite == enc) then
                                        print("Licenca ativada com sucesso!")
                                        tokenValid["SecretS"] = enc
                                        tokenValid["SecretSite"] = tokenFromSite
                                        dataLicence[1] = "LicencaAprovada"
                                        startScript()
                                        onStartBindAll()
                                    else
                                        licenceStop()
                                        print("Error: "..encode("Falha na protecao"))
                                    end
                                end
                            end)
                        end, 1000, 1)
                    end
                else
                    licenceStop()
                    print("Error: "..encode("Falha ao encontrar config"))
                end
            else
                licenceStop()
                print("Error: "..encode("Leitor de config"))
            end
        else
            licenceStop()
            print("Error: "..encode("Protecao de Meta"))
        end
    else
        licenceStop()
        print("Error: "..encode("Debug GetInfo"))
    end
end
addEventHandler("onResourceStart", getRootElement(), onStartProtect)

-------------------/PROTECAO INIT\-------------------

function isHaveProtection()
    return (dataLicence[1] == "LicencaAprovada" and tokenValid["SecretS"] == tokenValid["SecretSite"])
end